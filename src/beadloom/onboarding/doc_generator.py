"""Documentation skeleton generator from knowledge graph."""

# beadloom:domain=onboarding

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pathlib import Path

logger = logging.getLogger(__name__)


def _load_graph_from_yaml(
    project_root: Path,
) -> tuple[list[dict[str, Any]], list[dict[str, Any]]]:
    """Load all graph nodes and edges from ``.beadloom/_graph/*.yml``."""
    import yaml

    graph_dir = project_root / ".beadloom" / "_graph"
    nodes: list[dict[str, Any]] = []
    edges: list[dict[str, Any]] = []
    for yml in sorted(graph_dir.glob("*.yml")):
        if yml.name == "rules.yml":
            continue
        data = yaml.safe_load(yml.read_text(encoding="utf-8"))
        if data:
            nodes.extend(data.get("nodes", []))
            edges.extend(data.get("edges", []))
    return nodes, edges


def _generate_mermaid(
    nodes: list[dict[str, Any]],
    edges: list[dict[str, Any]],
) -> str:
    """Generate a Mermaid ``graph LR`` block from *edges*.

    Only ``part_of`` and ``depends_on`` edge kinds are included.
    ``depends_on`` renders as ``-->``, ``part_of`` as ``.->`` (dotted).
    """
    lines: list[str] = []
    for edge in edges:
        kind = edge.get("kind", "")
        src = edge.get("src", "")
        dst = edge.get("dst", "")
        if kind == "depends_on":
            lines.append(f"  {src} --> {dst}")
        elif kind == "part_of":
            lines.append(f"  {src} -.-> {dst}")
    return "\n".join(lines)


def _write_if_missing(path: Path, content: str) -> bool:
    """Write *content* to *path* only if the file does not yet exist.

    Returns ``True`` when a new file was created, ``False`` when skipped.
    """
    if path.exists():
        logger.debug("Skipping existing file: %s", path)
        return False
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    logger.info("Created: %s", path)
    return True


def _find_root_node(
    nodes: list[dict[str, Any]],
) -> dict[str, Any] | None:
    """Return the root service node (kind=service, empty source)."""
    for node in nodes:
        if node.get("kind") == "service" and not node.get("source", "").strip():
            return node
    return None


def _edges_for(
    ref_id: str,
    edges: list[dict[str, Any]],
) -> tuple[list[str], list[str]]:
    """Return (depends_on, used_by) lists for a given *ref_id*."""
    depends_on: list[str] = []
    used_by: list[str] = []
    for edge in edges:
        if edge.get("src") == ref_id:
            depends_on.append(edge.get("dst", ""))
        if edge.get("dst") == ref_id:
            used_by.append(edge.get("src", ""))
    return depends_on, used_by


def _children_of(
    ref_id: str,
    edges: list[dict[str, Any]],
) -> list[str]:
    """Return ref_ids of nodes that are ``part_of`` *ref_id*."""
    return [
        edge["src"]
        for edge in edges
        if edge.get("kind") == "part_of" and edge.get("dst") == ref_id
    ]


def _parent_of(
    ref_id: str,
    edges: list[dict[str, Any]],
) -> str | None:
    """Return the parent ref_id (via ``part_of`` edge) for *ref_id*."""
    for edge in edges:
        if edge.get("kind") == "part_of" and edge.get("src") == ref_id:
            return edge.get("dst", "")
    return None


# ------------------------------------------------------------------
# Architecture page
# ------------------------------------------------------------------


def _render_architecture(
    project_name: str,
    nodes: list[dict[str, Any]],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/architecture.md`` content."""
    domains = [n for n in nodes if n.get("kind") == "domain"]
    services = [n for n in nodes if n.get("kind") == "service" and n.get("source", "").strip()]

    domain_rows = "\n".join(
        f"| {d['ref_id']} | {d.get('summary', '')} | `{d.get('source', '')}` |" for d in domains
    )
    service_rows = "\n".join(
        f"| {s['ref_id']} | {s.get('summary', '')} | `{s.get('source', '')}` |" for s in services
    )

    mermaid = _generate_mermaid(nodes, edges)

    return (
        f"# {project_name} — Architecture\n"
        "\n"
        "> Auto-generated by `beadloom docs generate`. Edit to add context.\n"
        "\n"
        "## Domains\n"
        "\n"
        "| Domain | Summary | Source |\n"
        "|--------|---------|--------|\n"
        f"{domain_rows}\n"
        "\n"
        "## Services\n"
        "\n"
        "| Service | Summary | Source |\n"
        "|---------|---------|--------|\n"
        f"{service_rows}\n"
        "\n"
        "## Dependency Map\n"
        "\n"
        "```mermaid\n"
        "graph LR\n"
        f"{mermaid}\n"
        "```\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Domain README
# ------------------------------------------------------------------


def _render_domain_readme(
    node: dict[str, Any],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/domains/{name}/README.md`` content."""
    ref_id: str = node["ref_id"]
    summary: str = node.get("summary", "")
    source: str = node.get("source", "")

    depends_on, used_by = _edges_for(ref_id, edges)
    children = _children_of(ref_id, edges)

    dep_list = ", ".join(depends_on) if depends_on else "(none)"
    used_list = ", ".join(used_by) if used_by else "(none)"
    feat_list = "\n".join(f"- {c}" for c in children) if children else "(none)"

    return (
        f"# {ref_id}\n"
        "\n"
        f"> {summary}\n"
        "\n"
        "## Source\n"
        "\n"
        f"`{source}`\n"
        "\n"
        "## Dependencies\n"
        "\n"
        f"- Depends on: {dep_list}\n"
        f"- Used by: {used_list}\n"
        "\n"
        "## Features\n"
        "\n"
        f"{feat_list}\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Service page
# ------------------------------------------------------------------


def _render_service(
    node: dict[str, Any],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/services/{name}.md`` content."""
    ref_id: str = node["ref_id"]
    summary: str = node.get("summary", "")
    source: str = node.get("source", "")

    depends_on, used_by = _edges_for(ref_id, edges)
    dep_list = ", ".join(depends_on) if depends_on else "(none)"
    used_list = ", ".join(used_by) if used_by else "(none)"

    return (
        f"# {ref_id}\n"
        "\n"
        f"> {summary}\n"
        "\n"
        "## Source\n"
        "\n"
        f"`{source}`\n"
        "\n"
        "## Dependencies\n"
        "\n"
        f"- Depends on: {dep_list}\n"
        f"- Used by: {used_list}\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Feature SPEC
# ------------------------------------------------------------------


def _render_feature_spec(
    node: dict[str, Any],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/features/{name}/SPEC.md`` content."""
    ref_id: str = node["ref_id"]
    summary: str = node.get("summary", "")
    source: str = node.get("source", "")
    parent = _parent_of(ref_id, edges) or "(unknown)"

    return (
        f"# {ref_id}\n"
        "\n"
        f"> {summary}\n"
        "\n"
        "## Source\n"
        "\n"
        f"`{source}`\n"
        "\n"
        "## Parent\n"
        "\n"
        f"{parent}\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Polish helpers
# ------------------------------------------------------------------


def _symbols_for_node(
    node: dict[str, Any],
    symbols_by_source: dict[str, list[dict[str, Any]]],
) -> list[dict[str, Any]]:
    """Return code symbols whose file path starts with *node*'s source."""
    source = node.get("source", "").rstrip("/")
    if not source:
        return []
    result: list[dict[str, Any]] = []
    for fp, syms in symbols_by_source.items():
        if fp.startswith(source):
            result.extend(syms)
    return result


def _read_existing_doc(project_root: Path, node: dict[str, Any]) -> str | None:
    """Return existing doc content for *node*, or ``None`` if absent."""
    kind = node.get("kind", "")
    ref_id: str = node["ref_id"]
    docs_dir = project_root / "docs"
    candidates: list[Path] = []
    if kind == "domain":
        candidates.append(docs_dir / "domains" / ref_id / "README.md")
    elif kind == "service":
        candidates.append(docs_dir / "services" / f"{ref_id}.md")
    elif kind == "feature":
        candidates.append(docs_dir / "features" / ref_id / "SPEC.md")
    for c in candidates:
        if c.exists():
            return c.read_text(encoding="utf-8")
    return None


# ------------------------------------------------------------------
# Public API
# ------------------------------------------------------------------


def generate_polish_data(
    project_root: Path,
    ref_id: str | None = None,
) -> dict[str, Any]:
    """Generate structured data for AI agent to enrich documentation.

    Returns a dict with:
    - nodes: list of node data with symbols, deps, dependents
    - architecture: project overview
    - instructions: str prompt for the AI agent

    If *ref_id* is given, returns data for that single node.
    """
    from pathlib import Path as _Path  # runtime import

    nodes, edges = _load_graph_from_yaml(project_root)

    # Detect project name from root node.
    root_node = _find_root_node(nodes)
    project_name: str = root_node["ref_id"] if root_node else project_root.name

    # Load code symbols from SQLite DB (if available).
    db_path = _Path(project_root) / ".beadloom" / "beadloom.db"
    symbols_by_source: dict[str, list[dict[str, Any]]] = {}
    if db_path.exists():
        import sqlite3

        conn = sqlite3.connect(str(db_path))
        conn.row_factory = sqlite3.Row
        rows = conn.execute(
            "SELECT symbol_name, kind, file_path, line_start, line_end FROM code_symbols"
        ).fetchall()
        for row in rows:
            fp: str = row["file_path"]
            symbols_by_source.setdefault(fp, []).append(dict(row))
        conn.close()

    # Build node data list.
    target_nodes = nodes
    if ref_id is not None:
        target_nodes = [n for n in nodes if n["ref_id"] == ref_id]

    node_data_list: list[dict[str, Any]] = []
    for node in target_nodes:
        depends_on, used_by = _edges_for(node["ref_id"], edges)
        children = _children_of(node["ref_id"], edges)
        node_data: dict[str, Any] = {
            "ref_id": node["ref_id"],
            "kind": node.get("kind", ""),
            "summary": node.get("summary", ""),
            "source": node.get("source", ""),
            "symbols": _symbols_for_node(node, symbols_by_source),
            "depends_on": depends_on,
            "used_by": used_by,
            "features": children,
            "existing_docs": _read_existing_doc(project_root, node),
        }
        node_data_list.append(node_data)

    # Build Mermaid diagram.
    mermaid_str = _generate_mermaid(nodes, edges)

    # Build instructions prompt.
    instructions = (
        "You are enriching documentation for the software project "
        f"'{project_name}'. For each node below, write a concise but "
        "informative description based on its public API symbols, "
        "dependencies, and source paths. Replace placeholder text and "
        "expand skeleton docs with real architectural context. "
        "Use the update_node MCP tool to save improved summaries."
    )

    return {
        "nodes": node_data_list,
        "architecture": {
            "project_name": project_name,
            "mermaid": mermaid_str,
        },
        "instructions": instructions,
    }


def generate_skeletons(
    project_root: Path,
    nodes: list[dict[str, Any]] | None = None,
    edges: list[dict[str, Any]] | None = None,
) -> dict[str, int]:
    """Generate doc skeletons from graph nodes and edges.

    If *nodes*/*edges* are not provided, reads from the graph YAML files
    in ``.beadloom/_graph/``.

    Returns ``{"files_created": N, "files_skipped": M}``.
    """
    if nodes is None or edges is None:
        nodes, edges = _load_graph_from_yaml(project_root)

    # Detect project name from root node.
    root_node = _find_root_node(nodes)
    project_name: str = root_node["ref_id"] if root_node else project_root.name

    docs_dir = project_root / "docs"
    docs_dir.mkdir(parents=True, exist_ok=True)

    created = 0
    skipped = 0

    # 1. architecture.md
    arch_content = _render_architecture(project_name, nodes, edges)
    if _write_if_missing(docs_dir / "architecture.md", arch_content):
        created += 1
    else:
        skipped += 1

    # 2. Domain READMEs
    for node in nodes:
        if node.get("kind") != "domain":
            continue
        name = node["ref_id"]
        content = _render_domain_readme(node, edges)
        if _write_if_missing(docs_dir / "domains" / name / "README.md", content):
            created += 1
        else:
            skipped += 1

    # 3. Service pages (skip root node — empty source)
    for node in nodes:
        if node.get("kind") != "service":
            continue
        if not node.get("source", "").strip():
            # Root node — do not create a service page.
            continue
        name = node["ref_id"]
        content = _render_service(node, edges)
        if _write_if_missing(docs_dir / "services" / f"{name}.md", content):
            created += 1
        else:
            skipped += 1

    # 4. Feature SPECs
    for node in nodes:
        if node.get("kind") != "feature":
            continue
        name = node["ref_id"]
        content = _render_feature_spec(node, edges)
        if _write_if_missing(docs_dir / "features" / name / "SPEC.md", content):
            created += 1
        else:
            skipped += 1

    logger.info("Doc skeletons: %d created, %d skipped", created, skipped)
    return {"files_created": created, "files_skipped": skipped}
