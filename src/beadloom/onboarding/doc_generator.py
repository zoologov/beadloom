"""Documentation skeleton generator from knowledge graph."""

# beadloom:domain=onboarding

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from pathlib import Path

logger = logging.getLogger(__name__)


def _load_graph_from_yaml(
    project_root: Path,
) -> tuple[list[dict[str, Any]], list[dict[str, Any]]]:
    """Load all graph nodes and edges from ``.beadloom/_graph/*.yml``."""
    import yaml

    graph_dir = project_root / ".beadloom" / "_graph"
    nodes: list[dict[str, Any]] = []
    edges: list[dict[str, Any]] = []
    for yml in sorted(graph_dir.glob("*.yml")):
        if yml.name == "rules.yml":
            continue
        data = yaml.safe_load(yml.read_text(encoding="utf-8"))
        if data:
            nodes.extend(data.get("nodes", []))
            edges.extend(data.get("edges", []))
    return nodes, edges


def _generate_mermaid(
    nodes: list[dict[str, Any]],
    edges: list[dict[str, Any]],
) -> str:
    """Generate a Mermaid ``graph LR`` block from *edges*.

    Only ``part_of`` and ``depends_on`` edge kinds are included.
    ``depends_on`` renders as ``-->``, ``part_of`` as ``.->`` (dotted).
    """
    lines: list[str] = []
    for edge in edges:
        kind = edge.get("kind", "")
        src = edge.get("src", "")
        dst = edge.get("dst", "")
        if kind == "depends_on":
            lines.append(f"  {src} --> {dst}")
        elif kind == "part_of":
            lines.append(f"  {src} -.-> {dst}")
    return "\n".join(lines)


def _write_if_missing(path: Path, content: str) -> bool:
    """Write *content* to *path* only if the file does not yet exist.

    Returns ``True`` when a new file was created, ``False`` when skipped.
    """
    if path.exists():
        logger.debug("Skipping existing file: %s", path)
        return False
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    logger.info("Created: %s", path)
    return True


def _find_root_node(
    nodes: list[dict[str, Any]],
) -> dict[str, Any] | None:
    """Return the root service node (kind=service, empty source)."""
    for node in nodes:
        if node.get("kind") == "service" and not node.get("source", "").strip():
            return node
    return None


def _edges_for(
    ref_id: str,
    edges: list[dict[str, Any]],
) -> tuple[list[str], list[str]]:
    """Return (depends_on, used_by) lists for a given *ref_id*."""
    depends_on: list[str] = []
    used_by: list[str] = []
    for edge in edges:
        if edge.get("src") == ref_id:
            depends_on.append(edge.get("dst", ""))
        if edge.get("dst") == ref_id:
            used_by.append(edge.get("src", ""))
    return depends_on, used_by


def _children_of(
    ref_id: str,
    edges: list[dict[str, Any]],
) -> list[str]:
    """Return ref_ids of nodes that are ``part_of`` *ref_id*."""
    return [
        edge["src"]
        for edge in edges
        if edge.get("kind") == "part_of" and edge.get("dst") == ref_id
    ]


def _parent_of(
    ref_id: str,
    edges: list[dict[str, Any]],
) -> str | None:
    """Return the parent ref_id (via ``part_of`` edge) for *ref_id*."""
    for edge in edges:
        if edge.get("kind") == "part_of" and edge.get("src") == ref_id:
            return edge.get("dst", "")
    return None


# ------------------------------------------------------------------
# Architecture page
# ------------------------------------------------------------------


def _render_architecture(
    project_name: str,
    nodes: list[dict[str, Any]],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/architecture.md`` content."""
    domains = [n for n in nodes if n.get("kind") == "domain"]
    services = [n for n in nodes if n.get("kind") == "service" and n.get("source", "").strip()]

    domain_rows = "\n".join(
        f"| {d['ref_id']} | {d.get('summary', '')} | `{d.get('source', '')}` |" for d in domains
    )
    service_rows = "\n".join(
        f"| {s['ref_id']} | {s.get('summary', '')} | `{s.get('source', '')}` |" for s in services
    )

    mermaid = _generate_mermaid(nodes, edges)

    return (
        f"# {project_name} — Architecture\n"
        "\n"
        "> Auto-generated by `beadloom docs generate`. Edit to add context.\n"
        "\n"
        "## Domains\n"
        "\n"
        "| Domain | Summary | Source |\n"
        "|--------|---------|--------|\n"
        f"{domain_rows}\n"
        "\n"
        "## Services\n"
        "\n"
        "| Service | Summary | Source |\n"
        "|---------|---------|--------|\n"
        f"{service_rows}\n"
        "\n"
        "## Dependency Map\n"
        "\n"
        "```mermaid\n"
        "graph LR\n"
        f"{mermaid}\n"
        "```\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Domain README
# ------------------------------------------------------------------


def _render_domain_readme(
    node: dict[str, Any],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/domains/{name}/README.md`` content."""
    ref_id: str = node["ref_id"]
    summary: str = node.get("summary", "")
    source: str = node.get("source", "")

    depends_on, used_by = _edges_for(ref_id, edges)
    children = _children_of(ref_id, edges)

    dep_list = ", ".join(depends_on) if depends_on else "(none)"
    used_list = ", ".join(used_by) if used_by else "(none)"
    feat_list = "\n".join(f"- {c}" for c in children) if children else "(none)"

    return (
        f"# {ref_id}\n"
        "\n"
        f"> {summary}\n"
        "\n"
        "## Source\n"
        "\n"
        f"`{source}`\n"
        "\n"
        "## Dependencies\n"
        "\n"
        f"- Depends on: {dep_list}\n"
        f"- Used by: {used_list}\n"
        "\n"
        "## Features\n"
        "\n"
        f"{feat_list}\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Service page
# ------------------------------------------------------------------


def _render_service(
    node: dict[str, Any],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/services/{name}.md`` content."""
    ref_id: str = node["ref_id"]
    summary: str = node.get("summary", "")
    source: str = node.get("source", "")

    depends_on, used_by = _edges_for(ref_id, edges)
    dep_list = ", ".join(depends_on) if depends_on else "(none)"
    used_list = ", ".join(used_by) if used_by else "(none)"

    return (
        f"# {ref_id}\n"
        "\n"
        f"> {summary}\n"
        "\n"
        "## Source\n"
        "\n"
        f"`{source}`\n"
        "\n"
        "## Dependencies\n"
        "\n"
        f"- Depends on: {dep_list}\n"
        f"- Used by: {used_list}\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Feature SPEC
# ------------------------------------------------------------------


def _render_feature_spec(
    node: dict[str, Any],
    edges: list[dict[str, Any]],
) -> str:
    """Render ``docs/features/{name}/SPEC.md`` content."""
    ref_id: str = node["ref_id"]
    summary: str = node.get("summary", "")
    source: str = node.get("source", "")
    parent = _parent_of(ref_id, edges) or "(unknown)"

    return (
        f"# {ref_id}\n"
        "\n"
        f"> {summary}\n"
        "\n"
        "## Source\n"
        "\n"
        f"`{source}`\n"
        "\n"
        "## Parent\n"
        "\n"
        f"{parent}\n"
        "\n"
        "<!-- enrich with: beadloom docs polish -->\n"
    )


# ------------------------------------------------------------------
# Public API
# ------------------------------------------------------------------


def generate_skeletons(
    project_root: Path,
    nodes: list[dict[str, Any]] | None = None,
    edges: list[dict[str, Any]] | None = None,
) -> dict[str, int]:
    """Generate doc skeletons from graph nodes and edges.

    If *nodes*/*edges* are not provided, reads from the graph YAML files
    in ``.beadloom/_graph/``.

    Returns ``{"files_created": N, "files_skipped": M}``.
    """
    if nodes is None or edges is None:
        nodes, edges = _load_graph_from_yaml(project_root)

    # Detect project name from root node.
    root_node = _find_root_node(nodes)
    project_name: str = root_node["ref_id"] if root_node else project_root.name

    docs_dir = project_root / "docs"
    docs_dir.mkdir(parents=True, exist_ok=True)

    created = 0
    skipped = 0

    # 1. architecture.md
    arch_content = _render_architecture(project_name, nodes, edges)
    if _write_if_missing(docs_dir / "architecture.md", arch_content):
        created += 1
    else:
        skipped += 1

    # 2. Domain READMEs
    for node in nodes:
        if node.get("kind") != "domain":
            continue
        name = node["ref_id"]
        content = _render_domain_readme(node, edges)
        if _write_if_missing(docs_dir / "domains" / name / "README.md", content):
            created += 1
        else:
            skipped += 1

    # 3. Service pages (skip root node — empty source)
    for node in nodes:
        if node.get("kind") != "service":
            continue
        if not node.get("source", "").strip():
            # Root node — do not create a service page.
            continue
        name = node["ref_id"]
        content = _render_service(node, edges)
        if _write_if_missing(docs_dir / "services" / f"{name}.md", content):
            created += 1
        else:
            skipped += 1

    # 4. Feature SPECs
    for node in nodes:
        if node.get("kind") != "feature":
            continue
        name = node["ref_id"]
        content = _render_feature_spec(node, edges)
        if _write_if_missing(docs_dir / "features" / name / "SPEC.md", content):
            created += 1
        else:
            skipped += 1

    logger.info("Doc skeletons: %d created, %d skipped", created, skipped)
    return {"files_created": created, "files_skipped": skipped}
